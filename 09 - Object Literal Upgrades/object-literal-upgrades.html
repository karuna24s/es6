<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Object Literal Upgrades</title>
  </head>
  <body>
    <script>
      // We will cover some commonly used object literal upgrades. We have an
      // example here, where we have all these variables and want to put them in
      // to an object, where the property names are the same as the variables.
      // So we are going take the property names and place the variables in there.

      const first = 'snickers';
      const last = 'bos';
      const age = 2;
      const breed = 'King Charles Cav';
      // const dog = {
      //   first: first,
      //   last: last,
      //   age: age,
      //   breed: breed,
      // };
      // Now that is ok, but it is very repetitive as we are doing the samething
      // over and over again. We just made an object with all those variables
      // inside of it. If we add a console.log that you will see it is just a
      // regular object.
      // console.log(dog);
      // What we can do is if the property name and the variable you are setting
      // it to are named the exact same thing. You do not need to do this twice.
      // You can take out the variables:
      const dog = {
        firstName = first,
        last,
        age,
        breed,
        pals = ['Hugo, Sunny'],
      };
      console.log(dog);
      // This may look strange because this kind of looks like an array. But it
      // is an object. Doing that still gives the exact same object we are
      // looking for, just without the repetitive property name is equal to the
      // actual variable name. We don't have to go all in on that. That is only
      // when that is the actual case. For example if you want to rename a
      // property to firstName, and the variable could be first. That is no
      // problem there. If you want to add pals, it would an array. You only
      // need to use it when the property name and the variable name are
      // exactly the same.

      // Another upgrade is when you have method definitions inside of an
      // object. Let's say we have a modal object here, so let's call it
      // const modal = {} and inside of that we have three methods. We got
      // create, open and close. All of these are functions in which they are
      // just a function and after each on we have a comma.
      const modal = {
        create: function() {

        },
        open: function() {

        },
        close: function() {

        }
      }
      // Instead of that we can remove the word function and the colon.. that is
      // exact same thing as colon function. It is just a shorthand. There is
      // no weirdness with the keyword this or anything and that is exactly why
      // you should not use an arrow function when you are using a method of an
      // object, because you have this other shorthand here and it is not going
      // to interfere with the scoping of any of your variables or the keyword
      // this. Similarly if you had an params to pass in like maybe selector,
      // content, goodbye. You can pass them in as you normally would into a
      // function.
      const modal = {
        create(selector) {

        },
        open(content) {

        },
        close(goodbye) {

        }
      }
      // Another update to the object literal is computed property names. It is
      // also something that you might not use on a daily basis. However it is
      // good to know in case you ever run into a situation when you need it.
      // Here is an example where you have a key that needs to be set on an
      // object. You will make a key variable and it will be equal to pocketColor
      // since we are going to make tshirt and the tshirt has different attributes
      // like pocketColor, mainColor, inkColor, sleeveColor. You have the value
      // of the actual color set to yellow. You need to use these variables to
      // set a property and a value of an object. What you could do is create
      // an object literal.

      // Created this function that just takes in the hex code and returns the
      // inverseColor, so just the opposite color. If you want to make a key of
      // the pocketColor opposite, how could you do that? You could make another
      // variable here and then say pocketColorOpposite but that is not what you
      // looking for. What you need to do is to compute the copy, which is just
      // use a function, or a template string or any JavaScript right inside of
      // the property name.

      function invertColor(color) {
        return '#' + ("000000" + (0xFFFFFF ^ parseInt(color.substring(1),16)).toString(16)).slice(-6);
      }

      const key = 'pocketColor';
      const value = '#ffc600';
      const tshirt = {
        // what we are able to do is say that the key is equal to the actual value.
        // what if you want the opposite color to go along withe the value as well,
        // because maybe you are printing something on top of that pocket and you
        // need to know what is the exact opposite color of that? It could go on
        // top of it.
        [key] = value,
        // Get the key and then attach on the word Opposite. You can use this
        // invertColor function and take the value as well. Now you have pocketColor
        // and pocketColorOpposite. Those are being dynamically set on this actual
        // variable (value).
        [`${key}Opposite`]: invertColor(value)
      };
      // Previously what you had to do is make the tshirt object, then go and
      // update the tshirt object like this:
      // const tshire = {};
      // tshirt[key] = value,
      // tshirt[`${key}Opposite`]: invertColor(value)
      // which is not the end of the world, but it is kind of cool that you can
      // do it inside of an object literal.
      // As you define it, you can compute the property keys.

      // Let's look at one more example where sometimes you have some data that
      // you get from an API and you don't have much of an option to work with.
      // You would have a little bit of a nicer structure but sometimes you
      // might have a keys array, which has size, color and weight. Then you have
      // a values array, which has medium, red, and 100.
      const keys = ['size', 'color', 'weight'];
      const values = ['medium', 'red', 100];
      // And you need to make an object where you can say:
      const shirt = {
        // typically [keys[0]] and that is a computed property name here. One
        // cool thing that you could do is:
        [keys.shift()]: values.shift(),
        [keys.shift()]: values.shift(),
        [keys.shift()]: values.shift(),
      }
      console.log(shirt);
      // What happens here is that you just plucked off one from each of the
      // arrays as you went through. You can run the same code over and over
      // again. You can also loop over them and set it on the shirt after the
      // fact.
    </script>
  </body>
</html>
